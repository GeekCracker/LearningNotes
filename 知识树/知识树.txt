一、Java
	1、数据类型
		[1]基本数据类型（1个字节占8位二进制数）
			byte	1个字节 	-128(-2^7) ~ 127(2^7-1) 
			short	2个字节 	-32768(-2^15) ~ 32767(2^15-1)
			int		4个字节 	-2,147,483,648(-2^31) ~ 2,147,483,647(2^31-1)
			long	8个字节 	-9,223,372,036,854,775,808(-2^63) ~ 9,223,372,036,854,775,807(-2^63-1)
			float	4个字节
			double	8个字节
			char	2个字节
			boolean 1个字节 	true、false
		[2]引用类型
			对象、数组都是引用数据类型，所有的引用类型默认值都为null，在栈中存放堆或常量池中的地址			
			例如数据类型包装类型Byte、Short、Integer、Long等都是引用类型
	2、运算符
		[1]算数运算符
			+ - * / %
		[2]赋值运算符
			= += -= *= /= %=
		[3]比较运算符
			== != >= <= > <  
		[4]逻辑运算符
			& &&(短路与) | ||(短路或) ! ^
		[5]位运算符
			&(位与) |(位或) ^(异或) <<(左移) >>(右移) >>>(无符号右移) ~(取反)
		[6]三元运算符
			条件表达式?表达式1:表达式2
		[7]位运算符运算过程
			(1)&位与，相同位数数字同为1，结果为1，否则为0
				[a]正数
					例：3&2=?
					原码	3:00000011
							2:00000010
					反码	3:00000011
							2:00000010
					补码	3:00000011
							2:00000010
					结果补码  00000010
					结果反码  00000010
					结果原码  00000010
					结果	2
				[b]负数
					例: -3&2=?
					原码	-3:10000011
							 2:00000010
					反码	-3:11111100
							 2:00000010
					补码	-3:11111101
							 2:00000010
					结果补码   00000000
					结果反码   00000000
					结果原码   00000000
					结果	0
							
			(2)|位或，相同位数数字有一个为1，结果为1，否则为0
				[a]正数
					例:	3|2=?
					原码	3:00000011
							2:00000010
					反码	3:00000011
							2:00000010
					补码	3:00000011
							2:00000010
					结果补码  00000011
					结果反码  00000011
					结果原码  00000011
					结果	3
				[b]负数
					例: -3|2=?
					原码	-3:10000011
							 2:00000010
					反码	-3:11111100
							 2:00000010
					补码	-3:11111101
							 2:00000010
					结果补码   11111111
					结果反码   11111110
					结果原码   10000001
					结果	-1
			(3)^异或，相同位数数字相同，结果为0，否则为1
				[a]正数
					例: 3^2=?
					原码	3:00000011
							2:00000010
					反码	3:00000011
							2:00000010
					补码	3:00000011
							2:00000010
					结果补码  00000001
					结果反码  00000001
					结果原码  00000001
					结果	1
				[b]负数
					例: -3^2=?
					原码	-3:10000011
							 2:00000010
					反码	-3:11111100
							 2:00000010
					补码	-3:11111101
							 2:00000010
					结果补码   11111111
					结果反码   11111110
					结果原码   10000001
					结果	-1
			(4)<<左移，左移后去掉左边移动的位数，末尾补0
				[a]正数
					例: 3<<2=?
					原码		3:00000011
					反码		3:00000011
					补码		3:00000011
					左移两位  	00000011
					结果补码	  00001100
					结果反码	  00001100
					结果原码	  00001100
					结果	12
				[b]负数
					例: -3<<2=?
					原码		-3:10000011
					反码		-3:11111100
					补码		-3:11111101
					左移两位	 11111101
					结果补码	   11110100
					结果反码	   11110011
					结果原码	   10001100
					结果	-12
			(5)>>右移，右移后去掉右边移动的位数，正数高位补1，负数高位补0
				[a]正数
					例: 3>>2=?
					原码	3:00000011
					反码	3:00000011
					补码	3:00000011
					右移两位    00000010
					结果补码  00000000
					结果反码  00000000
					结果原码  00000000
					结果	0
				[b]负数
					例: -3>>2=?
					原码	-3:10000011
					反码	-3:11111100
					补码	-3:11111101
					右移两位	 11111101
					结果补码   11111111
					结果反码   11111110
					结果原码   10000001
					结果	-1
			(6)>>>无符号右移，右移后去掉右边移动的位数，高位补0
				[a]正数
					例: 3>>>2=?
					原码	3:00000011
					反码	3:00000011
					补码	3:00000011
					右移两位	00000011
					结果补码  00000000
					结果反码  00000000
					结果原码  00000000
					结果	0
				[b]负数
					例: -3>>>2=?
					原码	-3:10000011
					反码	-3:11111100
					补码	-3:11111101
					右移两位	 11111101
					结果补码   00111111
					结果反码   00111111
					结果原码   00111111
					结果	 8位计算环境：63
							32位计算环境: 1073741823
							64位计算环境: 4611686018427387903
			(7)~取反，逐位取反，包括符号位
				[a]正数
					例: ~3
					原码	3:00000011
					反码	3:00000011
					补码	3:00000011
					取反	  11111100
					结果补码  11111100
					结果反码  11111011
					结果原码  10000100
					结果	-4
				[b]负数
					例: ~-3
					原码	-3:10000011
					反码	-3:11111100
					补码	-3:11111101
					取反	   00000010
					结果补码   00000010
					结果反码   00000010
					结果原码   00000010
					结果	2
	3、流程控制
		if、else if、else、for、while、do while
	4、数组
		[1]静态数组
			int [] arr = new int[10];
		[2]动态数组
			int [] arr = new int[]{1,2,3};
			int [] arr = {1,2,3};
		[3]排序
			a、选择排序
			b、冒泡排序
			c、快速排序
			d、希尔排序
		[4]交集
		[5]并集
		[6]补集
	5、包、类、属性、方法
		[1]包package
			(1)什么是包
				包裹，背包 ，用来存放相关或同类的东西，并对此进行有效的管理。在java中，包在物理上就是文件夹，
				逻辑上代表一个分类概念，语句必须是能够运行的第一行,且只能有一个。表明该类的所处的 位置。
			(2)包的作用
			   [a]将包含类代码的文件组织起来，易于查找和使用适当的类
			   [b]包不止能包含类和接口，还能包含其他包，从而形成层次空间，方便管理
			   [c]控制代码访问权限       
			   [d]有助于避免命名冲突
			(3)如何表达包 :   package   com.xxx.aaa;
				注意: 每个源文件只有一个包的声明，而且包名全部小写。
			(4)编译和生成包
				带包编译    
					javac  -d .\  Test.java  
					javac  –d D:\test\  Test.java  D盘要有test目录				
			(5)带包运行
				  运行带包的程序，需要使用类的全路径，就是带包的路径
				  例如 : java  com.test.Test		
			(6)JDK常用的包
				   java.lang  : java 核心包。  用重要的Object类
				   Java.awt : 包含了构成抽象窗口工具集的多个类。跟管理图形用户界面(GUI)
				   Java.swing :完全Java版的图形用户界面(GUI)解决方案,提供很多组件
				   Java.net: 包含网络相关的操作类。如URL ,Socket等
				   Java.io :包含 输入/输出功能的类。
				   Java.util : 包含实用工具类，如系统特性，日期，集合框架等
		[2]类是一组具有相同特征和行为的事物的抽象概念
			(1)基本构成：
				属性、方法、构造方法、构造代码块、静态代码块、局部代码块、package包、import导包、内部类
		[3]属性是类的成员，是该类型事物的特征描述
			(1)全局属性(全局变量)
			(2)局部属性(局部变量)
			(3)静态属性(静态变量、类变量)
		[4]方法是类的成员，是该类型事物的行为描述
	6、修饰符
		[1]权限修饰符
			(1)public		公共的
				public可以用来修饰接口、类、属性、构造方法、成员方法，不能修饰内部类，同一个java文件只能有一个public修饰的类
			(2)protected	受保护的
				protected 可以修饰属性，构造方法，成员方法，不能修饰类（内部类除外）。
				在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法
			(3)default		默认
				default可以修饰属性、方法
			(4)privite		私有
				private可以修饰属性、构造方法、方法、成员内部类，不可以修饰代码块里定义的局部变量和内部类
			(5)访问控制
				修饰符		当前类		同一包内		子类（同一包内）		子类（不同包内）		其他包
				public		Y			Y				Y						Y						Y
				protected 	Y			Y				Y						Y/N						N
				default 	Y			Y				Y						N						N
				private 	Y			N				N						N						N
		[3]三大修饰符
			(1)static		静态
				[a]static可以用来修饰属性、方法、成员内部类，
				[b]被static修饰的属性，可以通过接口或类名直接调用，在类装载时就会初始化，无需调用时才初始化
				[c]被static修饰的方法，可以通过类型直接调用
			(2)final		终态
			(3)abstract		抽象
	7、面向对象
		[1]类的三大特性
			(1)继承
				[a]基本要素
					(a)两个类之间存在父子关系
					(b)子类可以使用不属于它的成员（该成员来自父类）
				[b]作用
					(a)避免类泛滥
					(b)避免代码重复，增加了代码的复用性
				[c]缺点
					(a)耦合度越高会导致代码之间的联系越紧密，独立性差
				[d]关键字
					(a)super
						a、super是调用父类或者超类中的内容，包括属性、构造方法、普通方法
						b、super(参数…)也只能放在子类构造方法的首行,所以不能跟this(参数…)共存,
							同样this(参数…)也只能放在构造方法首行
						c、当super调用属性或是普通方法时可以放在构造方法或者普通方法中，
							只能放在该关键字调用的构造方法之后，并且没有位置和数量限制
						d、重写（覆盖） 是修改父类中的方法体内容，子类需要修改父类中定义的方法的实现
							注意事项：①方法名相同
									  ②访问权限只能是扩大父类的或是不变，返回值类型只能是父类的返回值类型的子类或者是不变，
										参数列表不能改变，方法体内容可以选择性的改变
									  ③抛出的异常不能增多
						e、重载 是基于一个类中的方法
							注意事项：①方法名相同，参数列表不同， 参数类型不同，参数个数不同，跟返回值无关，跟访问权限无关 
			(2)封装
				[a]概念：封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。
				[b]优点
					(a)减少耦合，提高重用性
					(b)内部结构可以随意修改
					(c)对成员变量进行更精确的控制
					(d)隐藏信息，实现细节，提高安全性
			(3)多态
				[a]概念：一种动作的不同表现形式，一种类型的多种对象的实例，一种属性的多种表现形式
				[b]静态多态
					(a)重载
				[c]动态多态
					(a)继承
					(b)重写
					(c)父类引用，子类实现
				[d]好处
					提高了代码的扩展性，前期定义的代码可以使用后期的内容
				[e]弊端
					前期定义的内容不能调用后期子类特有的内容			
		[4]抽象类
		
		[5]接口
		
	8、类的执行顺序
		[1]同一个java文件中
			静态属性， 静态代码块（属性赋值），静态方法，
			非静态属性，构造代码块（属性赋值），构造方法，普通方法
		[2]父子级关系中
			父类的静态属性，父类的静态代码块（属性赋值），父类的静态方法，
			子类的静态属性，子类的静态代码块（属性赋值），子类的静态方法，
			父类的非静态属性，父类的非静态代码块（赋值），
			子类的非静态属性，子类的非静态代码块（赋值），
			父类的构造方法，子类的构造方法，
			创建对象后根据实际情况考虑普通方法的调用顺序 
	9、集合框架
		[1]Collection
			所有集合的超级接口，定义了集合共有的方法，只能存储引用类型对象
		[2]List
			(1)ArrayList
				[a]描述
					数组类型的集合，底层采用数组实现，默认是一个Object类型动态空数组，并动态的扩容，
					由于对集合的操作方法未采用到同步机制，所以是线程不安全的
				[b]常用方法
			(2)LinkedList
				[a]描述
					双端链表类型的集合，底层采用双端链表，每一个元素都对应一个Node，
					Node中存放了上一个Node和下一个Node的实例，以及当前的数据元素
				[b]常用方法，每次对集合进行添加和删除，都会更新修改次数，该集合不提供访问该次数的方法，可以通过子类新建方法获取该次数
					(a)add(e)
						添加一个元素，会调用addLast(e)方法向链表的最后一个位置添加一个元素
					(b)addAll(collection)
						添加一个集合元素，将集合内的所有元素追加到当前集合的末尾
					(c)addFirst(e)
						添加一个元素，会调用linkFirst(e)方法，将首个元素修改为指定元素，
						并将修改前首个元素的上一个元素修改为当前的首个元素，
						如果首个元素为空，即集合是空的，则会将last最后一个元素修改为指定元素，该Node的下一个节点也是空的，
						此时first和last都是同一个Node
					(d)addLast(e)
						添加一个元素，会调用linkLast(e)方法，将末尾元素修改为指定元素，
						并将修改前末尾元素的下一个元素修改为当前的末尾元素，
						如果末尾元素为空，即集合是空的，则会将first首个元素修改为指定元素，该Node的上一个节点也是空的，
						此时first和last都是同一个Node
					(e)remove(e)
						删除一个指定元素，从first开始遍历，删除第一个匹配到的元素
					(f)remove(index)
						删除一个指定下标的元素，下标为index，通过node(index)方法获取到指定下标处的元素，node方法里通过分治策略
						如果index小于集合大小的中位数，则从第一个元素开始遍历，否则从最后一个元素开始遍历，遍历到需要删除的元素的上一个或下一个元素，
						获取上一个元素的next或下一个元素的prev
					(g)removeFirst
						删除第一个元素，会调用unlinkFirst方法，将首个元素修改为需要删除的元素的下一个元素，
						并将下一个元素的上一个元素修改为null，
						如果下一个元素为空，即集合只有一个元素，将最后一个元素last修改为null
					(h)removeLast
						删除最后一个元素，会调用unlinkLast方法，将末尾元素修改为需要删除的上一个元素，
						并将上一个元素的下一个元素修改为null，
						如果上一个元素为空，即集合只有一个元素，将首个元素first修改为null
					(i)removeAll(collection)
						删除指定集合内的多个指定元素
			(3)Vector
				[a]描述
					数组类型的集合，底层采用数组实现，默认是一个容量为10的静态空数组，并动态的扩容，
					由于对集合的操作采用了synchronized同步机制，保证了多线程的原子性，所以是线程安全的
				[b]常用方法
					(a)add(e)
						添加一个元素，返回是否添加成功，成功为true，失败为false
					(b)addAll(collection)
						添加一个集合元素，将集合内的所有元素追加到当前集合的末尾
					(c)addElement(e)
						添加一个元素，和add(e)效果一样，只是没有返回值
					(d)remove(e)
						删除一个元素，返回是否删除成功，成功为true，失败为false，会调用removeElement
					(e)removeAll(collection)
						删除指定集合内的所有元素
					(f)removeElement(e)
						删除一个的元素，会调用removeElementAt，会改变数组的长度
					(g)removeElementAt(index)
						删除一个元素，通过指定的下标来删除，会改变数组的长度
					(h)removeAllElements()
						删除所有元素，不会改变底层存储元素的数组的长度
		[3]Set
			(1)HashSet
				[a]描述
					HashSet是由HashMap数据结构实现的集合，元素无序且不能重复。
					数据在HashMap中的结构是作为 key 存在的，而value统一都是Object PRESENT = new Object();
				[b]构造方法
					(a)无参构造方法
						public HashSet(){
							map = new HashMap<>();
						}
						直接创建一个HashMap，采用无参的HashMap构造方法，默认的容量是16，默认的加载因子是0.75
					(b)指定初始容量
						public HashSet(int initialCapacity){
							map = new HashMap<>(initialCapacity);
						}
						创建一个指定初始容量的HashMap，默认加载因子是0.75
					(c)指定初始容量和加载因子
						public HashSet(int initialCapacity, float loadFactor){
							map = new HashMap<>(initialCapacity, loadFactor);
						}
						创建一个指定初始容量和指定加载因子的HashMap
					(d)包含指定集合元素
						public HashSet(Collection<? extends E> c){
							map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
							addAll(c);
						}
						根据传入的集合创建一个计算得出的容量的HashMap，加载因子采用默认的0.75
				[c]常用方法
					(a)add(e)
						会调用map.put(e,PRESENT)方法，将添加的数据对象作为key，new Object()对象作为value，
						并返回是否添加成功
					(b)addAll(collection)
						添加一个集合元素，将指定集合内的元素添加到当前集合内
					(c)remove(e)
						删除一个集合元素，会调用map.remove(e)方法,并返回是否删除成功
					(d)removeAll(collection);
					(e)removeIf(filter)
						根据指定的过滤器来删除集合内的元素，可采用lambda表达式方式
					(f)clear()
						会调用map.clear()方法，清空集合
			(2)LinkedHashSet
			(3)TreeSet
		[4]Queue
			(1)ArrayBlockingQueue
			(2)DelayQueue
			(3)LinkedBlockingQueue
			(4)LinkedList
			(5)PriorityBlockingQueue
			(6)PriorityQueue
			(7)SynchronousQueue
			(8)Deque
			(9)ArrayDeque
			(10)LinkedBlockingDeque
		[5]Map
			(1)HashMap
			(2)HashTable
			(3)LinkedHashMap
			(4)TreeMap
			(5)Properties
		[6]Map.Entry
			Map键值对映射的元素对象，一个Entry对应一个key-value
		[7]Iterable
			集合的父级接口，即Collection的父接口，允许所有的接口都可以通过foreach来遍历，
			可以通过集合实例创建一个iterator迭代器来进行遍历
		[8]Iterator
			通过集合实例创建的迭代器对象，可以进行集合的遍历和增删改查操作
		[9]List和Set的比较
		
		[10]ArrayList、LinkedList和Vector的比较
		
		[11]HashSet和TreeSet的比较
		
		[12]HashMap和HashTable的比较
		
		[13]Collections工具类
		
	10、常用实用类
		[1]包装类
			(1)Byte
			(2)Short
			(3)Integer
			(4)Long
			(5)Float
			(6)Double
			(7)Char
			(8)Boolean
		[2]String
		
		[3]BigDecimal
		
		[4]BigInteger
		
		[5]Date
			(1)时间类型，表示特定的瞬间，精确到毫秒
			(2)常用方法(Date date = new Date())
				[a]date.after(otherDate);判断当前的时间是否在指定时间之后
				[b]date.before(otherDate);判断当前的时间是否在指定时间之前
				[c]date.compareTo(otherDate);比较两个时间的顺序
		[6]Calendar
		
		[7]SimpleDateFormat
		
		[8]Math
		
		[9]StringBuffer
		
		[10]StringBuilder
		
		[11]StringTokenizer(字符串解析分离)
		
		[12]Scanner
		
		[13]Comparable
		
		[14]Pattern与Match
		
		[15]Class
		
		[16]Object
		
		[17]System
		
	11、数据流
		[1]数据流对应关系
			(1)输入流<===>输出流
			(2)字节流<===>字符流
			(3)节点流<===>处理流
		[2]输入流
			(1)字节节点输入流
				InputStream
			(2)文件字节节点输入流  
				FileInputStream
			(3)缓冲字节处理输入流
				BufferedInputStream
			(4)转换字符处理输入流
				InputStreamReader
			(5)缓冲字符处理输入流
				BufferedReader
			(6)数据字节处理输入流
				DataInputStream
			(7)对象字节处理输入流
				ObjectInputStream
			(8)文件字符处理输入流
				FileReader
		[3]输出流
			(1)字节节点输出流
				OutputStream
			(2)文件字节节点输出流
				FileOutputStream
			(3)缓冲字节处理输出流
				BufferedOutputStream
			(4)转换字符处理输出流
				OutputStreamWriter
			(5)缓冲字符处理输出流
				BufferedWriter
			(6)数据字节处理输出流
				DataOutputStream
			(7)对象字节处理输出流
				ObjectOutputStream
			(8)文件字符处理输出流
				FileWriter
		[4]文件操作
			(1)创建文件
				[a]创建文件夹
					File file = new File("文件夹目录");
					file.makeDirs();
				[b]创建文件
					File file = new File("文件目录");
					file.createNewFile();
			(2)删除文件
				[a]删除文件夹
					(a)如果是空文件夹
						File file = new File("文件夹目录");
						file.delete();
					(b)如果是非空文件夹，需要递归删除
						public static void deleleDir(File file){
							if(file.exists()){
								if(file.isFile()){
									file.delete();
								}else {
									List<File> files = file.listFiles();
									for(File file : files){
										deleteDir(file);
									}
									file.delete();
								}
							}							
						}
				[b]删除文件
					File file = new File("文件目录");
					file.delete();
			(3)修改文件
				[a]修改文件名
					(a)思路1：根据新的文件名创建一个文件，拷贝旧的文件内容到新的文件里，再删除旧的文件
					存在问题：多线程下，会出现旧文件不存在，新文件已存在，或文件被占用的情况
					(b)
				[b]修改文件内容
					(a)覆盖原来的内容
						public static void write(File file, String content){
							if(!file.exists())
								throw new RuntimeException("文件不存在");
							if(!file.isDirectory())
								throw new RuntimeException("该目录为文件夹，不能执行该操作");
							BufferedWriter bw = null;
							try {
								bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file)));
								bw.write(content);
							} catch (Exception e) {
								e.printStackTrace();
							} finally {
								if(bw != null){
									try {
										bw.close();
									} catch (IOException e) {
										e.printStackTrace();
									}
								}
							}
						}
					(b)在原来的内容后面追加，主要区别点在于FileOutputStream构造方法的第二个参数
						public static void write(File file, String content){
							if(!file.exists())
								throw new RuntimeException("文件不存在");
							if(!file.isDirectory())
								throw new RuntimeException("该目录为文件夹，不能执行该操作");
							BufferedWriter bw = null;
							try {
								bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file,true)));
								bw.write(content);
							} catch (Exception e) {
								e.printStackTrace();
							} finally {
								if(bw != null){
									try {
										bw.close();
									} catch (IOException e) {
										e.printStackTrace();
									}
								}
							}
						}
			(4)查询文件
	12、线程
		[1]创建线程
			(1)Runnable
				public class NeedRun implements Runnable{
					@Override
					public void run(){
						for(;;){
							System.out.println("===========");
							try{
								Thread.sleep(1000);
							}catch(Exception e){
								e.printStackTrace();
							}
						}
					}
				}
				public static void main(String [] args){
					NeedRun needRun = new NeedRun();
					Thread thread = new Thread(needRun);
					thread.start();
				}
			(2)Thread
				public class NeedRun extends Thread{
					@Override
					public void run(){
						for(;;){
							System.out.println("===========");
							try{
								Thread.sleep(1000);
							}catch(Exception e){
								e.printStackTrace();
							}
						}
					}
				}
				public static void main(String [] args){
					NeedRun needRun = new NeedRun();
					needRun.start();
				}
			(3)Callable<T>
		[2]线程生命周期		
	13、GUI
	14、网络编程
		[1]概念
			网络编程指的是编写运行在多个设备的程序，这些设备通过网络连接起来
		[2]网络模型
			(1)网络模型一般是指OSI七层参考模型和TCP/IP四层参考模型
			(2)OSI七层参考模型
				[a]应用层
				[b]表示层
				[c]会话层
				[d]传输层
				[e]网络层
				[f]数据链路层
				[g]物理层
			(3)TCP/IP四层参考模型
				[a]应用层
				[b]传输层
				[c]网络层
				[d]网络接口层
		[3]TCP
			(1)概念
				TCP 是传输控制协议的缩写，是一种面向连接的、可靠的、基于字节流的传输层通信协议，
				它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP/IP。
			(2)Java实现
				Java中的TCP主要涉及ServerSocket和Socket两个类。前者被认为是服务端的一个实体，
				用于接受连接。后者则被认为是连接的一种封装，用于传输数据的客户端，类似于一个管道。
		[4]UDP
			(1)概念
				UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。
	15、属性文件Properties
	16、泛型
	17、枚举
	18、注解
	19、反射
	20、正则表达式
	21、国际化
	22、Xml解析
		[1]dom4j
		[2]jdom
		[3]sax
	23、DTD约束
	24、Schema约束
	25、JDBC数据库连接
	26、JVM虚拟机
二、Html
	1、标签
	2、属性
三、Css
	1、选择器
	2、CSS样式
	3、盒子模型
	4、定位
	5、浮动
	6、对齐
	7、尺寸
四、Js
	1、数据类型
	2、对象
		[1]创建对象的方式
		[2]原型对象链
	3、函数
	4、运算符
	5、流程控制
	6、事件
	7、JavaScript 对象
	8、Browser 对象
	9、BOM 对象
	10、DOM 对象
	11、HTML 对象
五、JQuery
	1、选择器
	2、文档处理
	3、表单校验
	4、事件
	5、效果
	6、ajax
	7、工具函数
六、Mysql数据库
	1、DDL
	2、DML
	3、数据类型
	4、视图
	5、函数
	6、事件
	7、事务
	7、触发器
	8、存储过程
	9、存储引擎
	10、索引
	11、数据备份
	12、数据恢复
	13、用户操作与授权	
七、NoSql(非关系型数据库):Redis、MongoDB
	1、Redis
		[1]简介
		
		[2]安装
			下载地址
			http://redis.io/download
			linux下载及安装
			wget http://download.redis.io/releases/redis-5.0.5.tar.gz
			#解压安装包
			tar xzf redis-5.0.5.tar.gz
			#切换到根目录
			cd redis-5.0.5
			#编译源码生成可执行文件
			make
		[3]启动和退出
			(1)启动server
				src/redis-server redis.conf(需要后台启动的话，修改daemonize值为yes)
			(2)进入client
				src/redis-cli
			(3)退出client
				[a]quit
				[b]exit
			(4)关闭server
				[a]pkill redis-server
				[b]kill 进程号
				[c]src/redis-cli shutdown
		[4]Redis核心数据结构及常用命令
			(1)string
				[a]描述
					字符串类型数据结构，key和value都是字符串，value最大可以容纳512M的数据
				[b]常用操作：
					(a)set key value					//存入字符串键值对
					(b)mset key value [key value...]	//批量存入字符串键值对
					(c)setnx key value					//存入一个不存在的键值对
					(d)get key							//获取一个字符串键值
					(e)mget key [key...]				//批量获取字符串键值
					(f)del key [key...]					//批量删除键
					(g)expire key seconds				//对一个键设置过期时间
				[c]原子操作：(同时只有一个线程执行该操作)
					(a)incr key							//将key中存储的数字加1
					(b)decr key							//将key中存储的数字减1
					(c)incrby key increment				//将key中存储的数字加上increment
					(d)decrby key decrement				//将key中存储的数字减去decrement
				[d]应用场景：
			(2)hash
				[a]描述
					hash数据结构，key是一个字符串，value是多个key-value键值对
				[b]常用操作：
					(a)hset key field value						//在一个哈希表中存入一个键值对
					(b)hmset key field value [field value...]	//在一个哈希表中存入多个键值对
					(c)hsetnx key field value					//存入一个不存在的哈希表键值对
					(d)hget key	field							//获取哈希表key对应的field键值
					(e)hmget key field [field...]				//获取哈希表key对应的多个field键值
					(f)hdel key field [field...]				//删除哈希表key对应的多个field键值
					(g)hlen key									//获取哈希表key中field键值的数量
					(h)hgetall key								//返回哈希表key中所有的filed键值
				[c]原子操作：(同时只有一个线程执行该操作)
					(a)hincrby key field increment				//将哈希表key中field键的数字加上increment
				[d]应用场景：
			(3)list
				[a]描述
					list数据结构，key是一个字符串，value是多个元素，元素之间可以重复，根据添加的顺序进行排序
				[b]常用操作：
					(a)lpush key value [value...]	//将一个或多个value值放到key的左边
					(b)rpush key value [value...]	//将一个或多个value值放到key的右边
					(c)lpop key						//移除并返回key列表的头元素
					(d)rpop key						//移除并返回key列表的尾元素
					(e)lrange key start stop		//返回key列表中指定区间内的所有元素
					(f)blpop key [key...] timeout	//移除并返回一个或多个key列表的头元素，若列表中没有元素，阻塞等待timeout秒，如果timeout=0一直处于阻塞等待状态
					(g)brpop key [key...] timeout	//移除并返回一个或多个key列表的尾元素，若列表中没有元素，阻塞等待timeout秒，如果timeout=0一直处于阻塞等待状态
				[c]应用场景：
					(a)Stack(栈) = lpush + lpop -> FILO先进后出
					(b)Queue(队列)	= lpush + rpop -> FIFO先进先出
					(c)Blocking MQ(阻塞队列) = lpush + brpop -> FIFO先进先出基础上加了出的阻塞，如果没有列表没有数据，处于指定时间的阻塞状态
			(4)set
				[a]描述
					set数据结构，key是一个字符串，value是多个元素，元素之间不能重复，并且是无序的
				[b]常用操作：
					(a)sadd key member [member...]	//往集合key中存入一个或多个元素，元素存在则忽略，若key不存在则创建
					(b)srem key member [member...]	//从集合key中删除一个或多个元素
					(c)smembers	key					//获取集合key中的所有元素
					(d)scard key					//获取集合key中的元素个数
					(e)sismember key member			//判断元素member是否存在于集合key中
					(f)srandmember key [count]		//从集合key中随机选出count个元素，元素不从集合key中删除
					(g)spop key [count]				//从集合key中随机选出count个元素，元素从集合key中删除
				[c]运算操作：
					(a)sinter key [key...]					//交集运算，取多个key集合的交集
					(b)sintersotre destination key [key...]	//交集运算，取多个key集合的交集，并放到新的集合destination中
					(c)sunion key [key...]					//并集运算，取多个key集合的并集
					(d)sunionstore destination key [key...]	//并集运算，取多个key集合的并集，并放到新的集合destination中
					(e)sdiff key [key...]					//差集运算，以第一个key集合为准，删除第一个集合中在其他集合中所存在的元素
					(f)sdiffstore destination key [key...]	//差集运算，以第一个key集合为准，删除第一个集合中在其他集合中所存在的元素，并放到新的集合destination中
				[d]应用场景：
					(a)抽奖
						a、点击参与抽奖加入集合
							sadd key userId
						b、查看参与抽奖所有用户
							smembers key
						c、抽取count名中奖者
							srandmember key count	//抽奖后不删除用户，用于单个奖项
							spop key count			//抽奖后删除用户，用于多个奖项，例如：一等奖，二等奖，三等奖
					(b)商品筛选
						sinter key [key...]	//取交集将商品分别放到多个分类集合里，取交集后，筛选出的就是符合条件的商品，缺点：添加商品时需要维护所有分类集合的数据，增加redis交互次数
			(5)zset
				[a]描述
					zset数据结构，key是一个字符串，value是多个元素，元素之间不能重复，并且是有序的
				[b]常用操作：
					(a)zadd key score member [[score member]...]	//往有序集合key中添加一个或多个带分值的元素，
					(b)zrem key member [member...]					//从有序集合key中删除一个或多个元素
					(c)zscore key member							//返回有序集合中元素member元素的分值
					(d)zincrby key increment member 				//为有序集合key中元素member的分值加increment
					(e)zcard key									//返回有序集合key中元素个数
					(f)zrange key start stop [withscores]			//根据集合元素分值正序获取集合key中的指定索引(非分值)范围内的元素，并可以选择是否查询分值
					(g)zrevrange key start stop [withscores]		//根据集合元素分值倒序获取集合key中的指定索引(非分值)范围内的元素，并可以选择是否查询分值
				[c]运算操作：
					(a)zunionstore destination numKeys key [key...]		//并集运算，获取多个key集合的并集，并放到新的指定的集合destination集合中，numKeys为参与计算的key集合个数
																		//如果多个key集合中存在相同的member元素，则并集内的member元素分值，是这几个key中该member元素分值的和
					(b)zinterstore destination numkeys key [key...]		//交集运算，获取多个key集合的交集，并放到新的指定的集合destination集合中，numKeys为参与计算的key集合个数
																		//如果多个key集合中存在相同的member元素，则并集内的member元素分值，是这几个key中该member元素分值的和
		[5]Redis核心原理
		
		[6]Redis持久化
			(1)rdb快照文件
				[a]开启快照
					save 900 1		//900秒内如果有1次数据更新的操作，则更新快照文件
					save 300 10		//300秒内如果有10次数据更新的操作，则更新快照文件
					save 60 10000	//60秒内如果有10000次数据更新的操作，则更新快照文件
				[b]关闭快照
					#save 900 1		//在配置文件里将该配置注释掉即可关闭
			(2)aof日志文件(Append Only File)
				[a]开启aof日志文件
					appendonly yes
				[b]关闭aof日志文件
					appendonly no
				[c]aof文件名
					appendfilename "appendonly.aof"
		[7]Redis集群
		
		[8]Redis缓存穿透
		
		[9]Redis缓存雪崩
	2、MongoDB
		[1]简介
			MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。
			MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。
		[2]安装
		
		[3]常用操作
		
		[4]核心原理
		
		
八、JavaEE
	1、Tomcat服务器
	2、Jetty服务器
	3、Servlet
		[1]生命周期
		[2]九大内置对象
		[3]四大作用域
	4、监听器
	5、过滤器
	6、拦截器
	7、JSP
	8、EL、JSTL
	9、Thymeleaf
九、Linux操作系统
	1、常用命令

十、版本控制工具
	1、Svn
	2、Git
		[1]基本命令：
			git add;将修改后的内容添加到git缓冲区，此时还没提交
			git commint -c 备注;将缓冲区的内容提交到本地的git仓库
			git pull;拉取远程的仓库内容到本地仓库
			git push;将本地仓库的内容推送到远程的仓库

十一、Spring

十二、SpringMVC
	
十三、MyBatis、MyBatisPlus、TkMapper、Hibernate
	1、MyBatis
	2、MyBatisPlus
十四、并发编程
	1、冯诺依曼计算机模型
	2、现代计算机硬件基本结构
	3、CPU内部结构
	4、CPU多核缓存架构
	5、缓存一致性协议(MESI)
	6、用户级线程(ULT)与内核级线程(KLT)
	7、Java线程的生命周期
	8、JMM内存模型
		[1]、概念：JMM与JVM内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，
				   通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，
				   以及屏蔽不同操作系统之间的差异，JMM是围绕原子性，有序性、可见性展开。
		[2]、Java内存模型与硬件内存架构的关系
		[3]、Java内存模型内存交互操作(JMM原子操作)
			(1)lock(锁定)
				作用于主内存的变量，把一个变量标记为一条线程独占状态
			(2)unlock(解锁)
				作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
			(3)read(读取)
				作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
			(4)load(载入)
				作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
			(5)use(使用)
				作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎
			(6)assign(赋值)
				作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量
			(7)store(存储)
				作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作
			(8)write(写入)
				作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中
	9、volatile原理
		[1]可见性与有序性
			多线程之间变量共享以实现可见性和有序性，volatile会被编译成lock汇编指令，用来通过MESI或BUS(I/O总线锁)方式实现多核和多线程之间变量一致性
		[2]指令重排与内存屏障
			(1)指令重排
				当一个原子操作中有多个指令时，如果一个指令出现等待状态，这个等待状态指的是，等待其他线程释放变量锁，为拿到变量，会一直处于等待状态，
				这时会出现指令重排，先运行下面的指令，以优化运行效率，会在java字节码文件执行器将文件编译成汇编指令时和CPU执行时进行指令的重排
			(2)内存屏障
				由于指令重排具有一定的危险性，造成错误的结果，所以有了内存屏障以禁止指令重排，内存屏障有多重实现方式，volatile是其中一种方式，
				还可以手动加内存屏障，例如：Java的Unsafe魔术类中的fullFence()读写屏障、loadFence()读屏障、storeFence()写屏障方式加屏障，
				还有其他方式，例如：CAS原子操作等
				内存屏障的类型：
					loadload	读读（先进行volatile读再进行volatile读）
					loadstore	读写（先进行voletile读再进行volatile写）
					storeload	写读（先进行voletile写再进行volatile读）
					storestore	写写（先进行voletile写再进行volatile写）
		[3]总线风暴
			由于CPU缓存与主内存之间存在过多的数据交互，即多个线程都可以同时通过总线来访问变量并执行，并发度过高，会不断占用总线，
			此情况在volatile和CAS等操作过多的使用时会产生，于是解决方案可以折中考虑，适当减少volatile和CAS操作，
			采用synchronized、Lock方式进行手动加锁方式达到目标结果
		[4]volatile和synchronized同时使用可以实现高并发场景下单例对象的创建，由于java创建对象分为三步原子操作，申请内存空间获取内存地址，实例化对象，为引用赋值内存地址，
			该三步原子操作不能保证原子性及有序性，所以可以通过volatile禁用指令重排，实现三步操作的原子性和有序性
	10、synchronized原理
	11、Lock(ReentrantLock)原理
	12、AQS(AbstractQueuedSynchronizer)原理
	13、线程池
	
十五、Redisson数据网格
	参考资料：https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95

十六、Nginx
	1、Linux下安装(基于源码包的方式安装)
		[1]解压安装包
			命令：tar -zxvf nginx-1.14.0.tar.gz
		[2]对源码进行二进制编译，生成objs目录，包含要安装的nginx的模块，以及相对应的源码
			a、命令：./configure
			b、携带参数（包含安装时的配置信息以及需要安装的模块等），官网：Building nginx from Sources
		[3]生成(构建)nginx二进制执行文件
			命令：make
		[4]安装nginx到指定的目录，默认/usr/local/nginx
			命令：make install
	2、添加、更新nginx模块
		[1]进入到解压目录
			(1)命令:
				[a]./configure --需要添加或更新的模块
				[b]make 构建nginx二进制执行文件
				[c]make install 拷贝并备份nginx二进制执行文件到安装目录
	3、常用nginx命令
		[1]nginx -?
			描述：查看nginx命令提示
		[2]nginx -v
			描述：查看nginx版本
		[3]nginx -V
			描述：查看nginx版本，并罗列出所有已经安装了的模块
		[4]nginx -t
			描述：检查nginx配置文件是否合法，会提示不合法配置的位置，在修改nginx配置时可以使用
		[5]nginx -s stop
			描述：立即停止nginx服务
		[6]nginx -s quit
			描述：优雅的停止nginx服务，在服务停止前会陆续关闭没有访问的端口，访问中的，等访问结束后会关闭
		[7]nginx -s reopen
			描述：重新打开日志文件，更改日志文件句柄引用，不包含reload功能，不能重新加载配置文件
			场景：如果nginx日志文件过大，需要重新创建一个日志文件，把之前的重命名，再新建一个日志文件，
				  由于文件句柄跟随文件，记录日志是根据文件句柄查找文件，所以，新的日志信息还是在原来的日志文件里，
				  此时，就需要执行该命令，重新引用句柄
		[8]nginx -s reload
			描述：重新加载配置文件，当配置文件修改后，如果不想重启，直接用该命令重新加载配置文件即可
		[9]nginx -c filename
			描述：指定配置文件启动nginx
		[10]nginx -g "启动参数"
			描述：启动时可以传递参数修改默认配置
			例如：nginx -g "user root;" 修改nginx进程的指定用户
	4、nginx配置
		[1]server
			描述：配置一个站点，包含访问的服务名和端口信息和静态文件目录或代理站点信息等
		[2]listen
			描述：配置访问的端口
		[3]server_name
			描述：配置服务名，具体为IP或域名
		[4]
		
		
		[7]日志格式
	
十七、BootStrap

十八、EasyUI

十九、LayUI

二十、NodeJS

二十一、Vue

二十二、React

二十三、AngularJS

二十四、数据结构与算法
	1、数据结构包含的内容
		[1]逻辑结构
		[2]存储结构
		[3]数据运算
	2、分类
		[1]线性结构
		[2]非线性结构
	3、存储方式
		[1]顺序存储
		[2]链接存储
		[3]索引存储
		[4]散列存储
	4、时间复杂度
		[1]	计算方式
			案例：
				int a=0,b=0;
				for(int i=1;i<n;i++){
					for(int j=1;j<n;j++){
						a++;
						b++; 
					}
				}
			分析：
				for(i=1;i<=n;i++)该行 i的取值范围是1~n，所以频度为n
				for(j=1;j<n;j++)该行的频度取决于外层循环，为n，该循环内部的频度取决于这两层的循环，为n*n=n^2
				
				整体的时间复杂度为：T(n) = O(n^2 + n + n)
				最快的增长项为n^2，所以T(n) = O(n^2)
	5、空间复杂度

二十五、系统调优
	1、Mysql调优
	2、Tomcat调优
	3、Nginx调优
	4、JVM调优
	
二十六、JXL、POI、JACOB办公文档处理

二十七、Activti流程控制引擎

二十八、ELK(Elasticsearch、Logstash、Kibana)数据分析框架

二十九、分库分表中间件TDDL Smart Client、Atlas、Cobar、MyCat、Oceanus、OneProxy、ShardingSphere
	1、TDDL Smart Client
	2、Atlas
	3、Cobar
	4、MyCat
	5、Oceanus
	6、OneProxy
	7、ShardingSphere
		[1]官方文档
			https://shardingsphere.apache.org/index_zh.html
		[2]简介
		
		[3]数据分片
		[4]读写分离
		[5]分布式事务
		[6]SPI扩展
		[7]Sharding-JDBC
		[8]Sharding-Proxy
		[9]Sharding-Sidecar
三十、Netty

三十一、SPI、Dubbo
	1、SPI
	2、Dubbo
		[1]配置文件
			(1)
			(2)spring boot
				[a]dubbo.registry.protocol=zookeeper
					注册中心协议，支持的注册中心有：multicast、zookeeper、redis
				[b]dubbo.registry.address=127.0.0.1:2181
					注册中心地址，多个用逗号隔开，默认采用轮训负载均衡方式访问
				[c]dubbo.protocol.name=dubbo
					dubbo协议名称
				[d]dubbo.protocol.port=20880
					dubbo服务端端口
				[e]dubbo.protocol.serialization=fastjson
					dubbo远程调用时的序列化、反序列化方式，默认为 hessian2
					支持的序列化方式有：java、compactedjava、nativejava、fastjson、dubbo、fst、hessian2、kryo
		[2]存在问题
			(1)集成MybatisPlus时QueryWrapper参数传递时序列化方式
				[a]支持的方式
					(a)java
					(b)compactedjava
					(c)fastjson
				[b]不支持的方式
					https://ask.csdn.net/questions/759545
					(a)hessian2(dubbo默认序列化方式)
					(b)nativejava
					(c)dubbo(直接启动不起来)
					(d)fst
					(e)kryo
三十二、Zookeeper
	1、概要
		Zookeeper是用于分布式应用程序的协调服务。它公开了一组简单的API，分布式应用程序可以基于这些API用于同步节点状态、配置信息、服务注册信息等。
		其由JAVA编写，支持JAVA和C两种客户端语言
	2、官网 https://zookeeper.apache.org/
	3、下载 http://zookeeper.apache.org/releases.html#download
		apache-zookeeper-x.x.x-bin.tar.gz 编译好的可执行文件
		apache-zookeeper-x.x.x.tar.gz 源码包
	4、安装
		tar -zxvf apache-zookeeper-x.x.x-bin.tar.gz
	5、启动
		{zk_home}/bin/zkServer.sh
	6、配置
	
	7、常用命令
	
	8、Node节点
		[1]节点类型
			(1)PERSISTENT
				[a]持久节点(默认创建的节点)
				[b]创建方式：create /xxx
			(2)PERSISTENT_SEQUENTIAL
				[a]持久序号节点
				[b]创建时zookeeper会在路径上加上序号作为后缀，非常适合用于分布式锁、分布式选举等场景
				[c]创建方式：create -s /xxx
			(3)EPHEMERAL
				[a]临时节点
				[b]临时节点会在客户端回话断开后自动删除，适用于心跳，服务发现等场景
				[c]创建方式：create -e /xxx
			(4)EPHEMERAL_SEQUENTIAL
				[a]临时序号节点
				[b]与持久节点类似，不同在于临时序号节点会在客户端回话断开后自动删除
				[e]创建方式：create -e -s /xxx
		[2]节点监听(WATCH)
			客户端添加 -w 参数可实时监听节点与子节点的变化，并且实时收到通知。非常适用保障分布式情况下的数据一至性
			(1) ls -w path
				监听子节点的增加和删除
			(2) get -w path
				监听子节点的数据变化
			(3) stat -w path
				监听节点属性的变化
			(4) printwatches on|off
				触发监听后，是否打印监听事件(默认on)
		[3]节点属性(STAT)
			(1)查看当前节点属性
				stat /xxx
			(2)创建节点的事物ID
				cZxid=0x385
			(3)创建时间
				ctime=Tue Sep 24 17:26:28 CST 2019
			(4)修改节点的事物ID（当前节点数据修改）
				mZxid=0x385
			(5)最后修改时间
				mtime=Tue Sep 24 17:26:28 CST 2019
			(6)字节点变更事物ID（子节点增加或删除）
				pZxid=0x385
			(7)当前znode节点的子节点的变更次数（子节点增加或删除）
				cversion=0
			(8)当前znode节点数据版本变更次数
				dataVersion=0
			(9)权限版本变更次数
				aclVersion=0
			(10)节点拥有者（0x0表示没有拥有者，即该节点为持久节点，否则为临时节点，值为节点拥有者的回话ID）
				ephemeralOwner=0x0
			(11)数据长度（单位字节）
				dataLength=5
			(12)子节点数量
				numChildren=3
		[4]权限设置(ACL)
			ACL全称Access Control List（访问控制列表），用于控制资源的访问权限。Zookeeper使用ACL来控制对其znode的访问。
			基于 scheme:id:permission 的方式进行权限控制。 scheme 表示授权模式、 id 表示模式对应值、 permission 表示具体的增删改权限位
			
			ACL权限对应于具体的节点，针对于具体的节点进行权限的设置
			(1)scheme:认证模式
				[a]world
					开放模式，world表示全世界都可以访问（默认设置）
					(a)设置权限
						setAcl world:anyone:dcrwa
				[b]ip
					ip模式，限定客户端IP访问
				[c]auth
					用户密码认证模式，只有在会话中加了认证才可以访问
					(a)设置权限
						setAcl /xxx auth:用户名:密码:cdrwa
				[d]digest
					与auth类似，区别在于auth用明文密码，而digest用sha-1 + base64 加密后的密码。实际使用中digest更常用
					(a)密钥生成
						在Linux命名行输入
						echo -n 用户名:密码 | openssl dgst -binary -sha1 | openssl base64
						生成的密钥
						u53OoA8hprX59uwFsvQBS3QuI00=
					(b)设置权限
						setAcl /xxx digest:用户名:密钥:cdrwa
			(2)permission:权限位
				[a]CREATE
					可以创建子节点
				[b]DELETE
					可以删除子节点（仅下一级节点）
				[c]READ
					可以读取节点数据及显示子节点列表，不包括读取子节点数据
				[d]WRITE
					可以设置节点数据
				[e]ADMIN
					可以设置节点访问控制列表权限
			(3)ACL相关命令
				getAcl  :	getAcl /xxx				查看acl权限
				setAcl	:	setAcl /xxx acl			设置acl权限
				addauth :	addauth 用户名:密码		添加认证用户
三十三、JMS、ActiveMQ、Kafka、RocketMQ、RabbitMQ、ZeroMQ
	1、消息中间件
		[1]作用:
			(1)异步处理
			(2)应用解耦
			(3)限流销峰
		[2]缺点
			(1)可用性降低
			(2)复杂度增高
		[3]应用场景
			订单系统->下订单后，通知多个系统，完成下单业务以及统计订单数据，减库存，财务报表等
			短信、邮件系统->
			聊天窗口->
				.
				.
				.
		[4]所具备功能
			(1)优先级队列
			(2)延迟队列
			(3)死信队列
				当消息消费失败时，该消息会进入死信队列重新尝试消费，以保证消息不会丢失
			(4)队列模式
			(5)消费模式(pull/push)
				Topic主题发布-订阅模式下存在这两种模式
				[a]pull
					主动权在于消费方，优点是按需消费，而且服务端队列堆积的消息处理也相对简单；
					缺点是存在消息延迟，无法确定拉取消息时间，
				[b]push
					主动权在于服务方，优点是实时性高，服务端可以统一管理来进行负载，不过也容易导致慢消费；
					缺点就是发送消息的状态是集中式管理，对于服务端(broker)来说压力过大
			(6)消息回溯
			(7)消息堆积
			(8)消息持久化
				[a]策略刷盘
				[b]定期刷盘
				[c]手动刷盘
			(9)消息追踪
			(10)消息过滤
			(11)流量控制
			(12)消息顺序消费
			(13)安全机制
			(14)消息幂等性
			(15)事务消息
				.
				.
				.
	2、JMS
		[1]简介
			JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，
			是一组Java应用程序接口，它提供消息的创建、发送、读取等一系列服务用于在两个应用程序之间，或分布式系统中发送消息，
			进行异步通信。JMS提供了一组公共应用程序接口和响应的语法，类似于Java数据库的统一访问接口JDBC。
			Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。
		[2]消息模型
			(1)P2P(Ponit to Point)模型
				P2P模型，即采用点对点的方式发送消息。P2P模型是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息，
				队列的存在使得消息的异步传输称为可能，P2P模型在点对点的情况下进行消息传递时采用。
			(2)Pub/Sub(Publish/Subscribe)发布-订阅模型
				Pub/Sub发布-订阅模型定义了如何向一个内容节点发布和订阅消息，这个内容节点称为topic(主题)。主题可以认为是消息传递的中介，消息发布这将消息发布到某个主题，
				而消息订阅者则从主题订阅消息。主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布-订阅模型在消息的一对多广播时采用。
	3、ActiveMQ
		[1]简介
			ActiveMQ是Apache所提供的一个开源的消息系统，完全采用Java来实现，因此，它能很好地支持J2EE提出的JMS（Java Message Service,即Java消息服务）规范。
		[2]安装
			(1)下载地址
				http://activemq.apache.org/components/classic/download/
			(2)linux安装
			(3)windows安装
				(a)解压apache-activemq-5.15.10-bin.zip文件压缩包
				(b)进入bin目录下，选择64位或32位
					先点击InstallService.bat文件安装服务
					再点击activemq.bat文件启动即可
		[3]基本使用
			(1)添加依赖
				<dependency>
					<groupId>org.apache.activemq</groupId>
					<artifactId>activemq-core</artifactId>
					<version>5.7.0</version>
				</dependency>
			(2)消息提供者(P2P模型)
				(a)第一步:创建连接工厂类
					String brokerURL = "tcp://localhost:61616";//ActiveMQ服务器对外提供服务的url
					ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerURL);
				(b)第二步:创建连接并启动连接
					ActiveMQConnection connection = (ActiveMQConnection)connectionFactory.createConnection();
					connection.start();
				(c)第三步:创建会话
					//参数列表:
					//第一个参数:是否支持事务，如果为true，则会忽略第二个参数，被jms服务器设置为SESSION_TRANSACTED
					//第二个参数:当第一个参数为false时，第二个参数值可为Session.AUTO_ACKNOWLEDGE，Session.CLIENT_ACKNOWLEDGE，Session.DUPS_OK_ACKNOWLEDGE其中一个。
					//			 Session.AUTO_ACKNOWLEDGE 为自动确认，客户端发送和接收消息不需要做额外的工作。哪怕是接收端发生异常，也会被当作正常发送成功。
					//			 Session.CLIENT_ACKNOWLEDGE 为客户端确认。客户端接收到消息后，必须调用javax.jms.Message的acknowledge方法。jms服务器才会当作发送成功，并删除消息。
					//			 Session.DUPS_OK_ACKNOWLEDGE 允许副本的确认模式。一旦接收方应用程序的方法调用从处理消息处返回，会话对象就会确认消息的接收；而且允许重复确认。
					ActiveMQSession session = (ActiveMQSession)connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
				(d)第四步:创建队列
					String queueName = "queueName";//队列名称
					Destination destination = session.createQueue(queueName);
				(e)第五步:创建消息提供者
					MessageProducer producer = session.createProducer(destination);
				(f)第六步:发送消息
					TextMessage textMessage = session.createTextMessage();
					textMessage.setStringProperty("msg","操作成功！");
					producer.sendMessage(textMessage);
				(g)第七步:关闭连接
					connection.close();
			(3)消息消费者(P2P模型)
				(a)第一步:创建连接工厂类
					String brokerURL = "tcp://localhost:61616";//ActiveMQ服务器对外提供服务的url
					ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerURL);
				(b)第二步:创建连接并启动连接
					ActiveMQConnection connection = (ActiveMQConnection)connectionFactory.createConnection();
					connection.start();
				(c)第三步:创建会话
					//参数列表:
					//第一个参数:是否支持事务，如果为true，则会忽略第二个参数，被jms服务器设置为SESSION_TRANSACTED
					//第二个参数:当第一个参数为false时，第二个参数值可为Session.AUTO_ACKNOWLEDGE，Session.CLIENT_ACKNOWLEDGE，Session.DUPS_OK_ACKNOWLEDGE其中一个。
					//			 Session.AUTO_ACKNOWLEDGE 为自动确认，客户端发送和接收消息不需要做额外的工作。哪怕是接收端发生异常，也会被当作正常发送成功。
					//			 Session.CLIENT_ACKNOWLEDGE 为客户端确认。客户端接收到消息后，必须调用javax.jms.Message的acknowledge方法。jms服务器才会当作发送成功，并删除消息。
					//			 Session.DUPS_OK_ACKNOWLEDGE 允许副本的确认模式。一旦接收方应用程序的方法调用从处理消息处返回，会话对象就会确认消息的接收；而且允许重复确认。
					ActiveMQSession session = (ActiveMQSession)connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
				(d)第四步:创建队列
					String queueName = "queueName";//队列名称
					Destination destination = session.createQueue(queueName);
				(e)第五步:创建消息消费者
					MessageConsumer consumer = session.createConsumer(destination);
				(f)第六步:消费消息
					consumer.setMessageListener(new MessageListener() {
						@Override
						public void onMessage(Message message) {
							try {
								String msg = message.getStringProperty("msg");
								System.out.println(msg);
							} catch (JMSException e) {
								e.printStackTrace();
							}
						}
					});
				(g)第七步:关闭连接
					connection.close();
		[4]SpringBoot集成
		
		[5]支持客户端语言
			Java、C、C++、C#、Ruby、Perl、Python、AJAX和PHP
		[6]特点
			(1)优点
				[a]实现简单，可以快速上手
				[b]可控性比较好，还有比较好的监控机制和界面
			(2)缺点
				[a]吞吐量低
					每秒处理的请求数低，不能在高并发的场景下使用
				[b]无分片功能
					无消息分片功能，不支持集群服务，单机环境下不能处理大量的请求，需手动分片
	4、Kafka
	
	5、RocketMQ
		[1]简介
			
		[2]安装
		[3]基本使用
		[4]消息持久化
		[5]SpringBoot集成
		[6]支持客户端语言
		[7]特点
			(1)优点
			(2)缺点
	6、RabbitMQ
		[1]简介
			RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件），由Rabbit科技有限公司所开发,。
			RabbitMQ服务器是用爱立信公司所开发的Erlang语言编写的，继承了Erlang自身高并发的特性，而集群和故障转移是构建在开放电信平台框架上的。
			所有主要的编程语言均有与代理接口通讯的客户端库。
		[2]安装
			(1)下载地址
				https://www.rabbitmq.com/download.html
			(2)linux安装
				[a]安装erlang
				[b]安装rabbitmq
			(3)windows安装
		[3]基本使用
			(1)添加依赖
				<dependency>
					<groupId>com.rabbitmq</groupId>
					<artifactId>amqp-client</artifactId>
					<version>3.6.5</version>
				</dependency>
			(2)直连交换机(DirectExchange)	
				[a]简述
					直连交换机，默认的交换机类型，如果没有指定交换机，会通过Broker服务器默认指定的交换机进行消息的传递，
					前提条件是消费者绑定的队列名称和路由键名称一致，这是RabbitMQ的容错机制，正如RabbitMQ管理页面上对默认交换机的描述：
					The default exchange is implicitly bound to every queue, with a routing key equal to the queue name. 
					It is not possible to explicitly bind to, or unbind from the default exchange. It also cannot be deleted.
					默认交换器隐式地绑定到每个队列，路由键等于队列名称。无法显式绑定到默认交换器或从默认交换器取消绑定。它也不能被删除。
					绑定了直连交换机的所有队列，同一份消息只能被其中的一个队列对应的消费者所消费，如果消息没有被消费者消费，会一直存在于交换机内，
					直到有消费者队列绑定到该交换机，内部有负载均衡的算法
				[b]消息提供者
					(a)第一步:创建连接工厂，并设置工厂属性
						ConnectionFactory connectionFactory = new ConnectionFactory();
						connectionFactory.setHost("111.231.111.161");//服务器ip
						connectionFactory.setPort(5672);//服务器提供服务的端口
						connectionFactory.setVirtualHost("/test");//虚拟主机
						connectionFactory.setUsername("zhangsan");//登录用户名
						connectionFactory.setPassword("123456");//登录密码
					(b)第二步:通过连接工厂创建连接
						Connection connection = connectionFactory.newConnection();
					(c)第三步:通过连接创建消息通道
						Channel channel = connection.createChannel();
					(d)第四步:发送消息
						AMQP.BasicProperties props = new AMQP.BasicProperties();//基础属性，可以为null
						String message = "消息消息";
						channel.basicPublish("exchange001","routingKey001",props,message.getBytes());
					(e)第五步:关闭连接
						channel.close();
						connection.close();
				[c]消息消费者
					(a)第一步:创建连接工厂，并设置工厂属性
						ConnectionFactory connectionFactory = new ConnectionFactory();
						connectionFactory.setHost("111.231.111.161");//服务器ip
						connectionFactory.setPort(5672);//服务器提供服务的端口
						connectionFactory.setVirtualHost("/test");//虚拟主机
						connectionFactory.setUsername("zhangsan");//登录用户名
						connectionFactory.setPassword("123456");//登录密码
					(b)第二步:通过连接工厂创建连接
						Connection connection = connectionFactory.newConnection();
					(c)第三步:通过连接创建消息通道
						Channel channel = connection.createChannel();
					(d)第四步:声明消息通道的队列
						String queueName = "routingKey001";
						//参数列表:队列名称，是否持久化队列，是否独占，是否自动删除队列，其他参数
						channel.queueDeclare(queueName,true,false,false,null);
					(e)第五步:创建消息消费者
						QueueingConsumer consumer = new QueueingConsumer(channel);
					(f)第六步:消费消息
						QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();
						System.out.println(new String(delivery.getBody()));
					(g)第七步:消息消费完成确认
						//参数列表：队列名称
						//          是否自动签收，保证消息可靠性投递
						//          消费者对象
						channel.basicConsume(queueName,true,queueingConsumer);
					(h)第八步:关闭连接
						channel.close();
						connection.close();
			(3)主题交换机(TopicExchange)
				[a]简述
					
				[b]消息提供者
					(a)第一步:创建连接工厂，并设置工厂属性
						ConnectionFactory connectionFactory = new ConnectionFactory();
						connectionFactory.setHost("111.231.111.161");//服务器ip
						connectionFactory.setPort(5672);//服务器提供服务的端口
						connectionFactory.setVirtualHost("/test");//虚拟主机
						connectionFactory.setUsername("zhangsan");//登录用户名
						connectionFactory.setPassword("123456");//登录密码					
					(b)第二步:通过连接工厂创建连接
						Connection connection = connectionFactory.newConnection();
					(c)第三步:通过连接创建消息通道
						Channel channel = connection.createChannel();						
					(c)第四步:携带多个路由键向指定的交换机内发布消息
						String exchangeName = "topicExchange";//主题交换机名称
						String routingKey001 = "topic.routing";
						String routingKey002 = "topic.routing.key002";
						String routingKey003 = "topic.routing.key003";
						
						channel.basicPublish(exchangeName,routingKey001,null,"第一条消息".getBytes());
						channel.basicPublish(exchangeName,routingKey002,null,"第二条消息".getBytes());
						channel.basicPublish(exchangeName,routingKey003,null,"第三条消息".getBytes());
						
				[c]消息消费者
					(a)第一步:创建连接工厂，并设置工厂属性
						ConnectionFactory connectionFactory = new ConnectionFactory();
						connectionFactory.setHost("111.231.111.161");//服务器ip
						connectionFactory.setPort(5672);//服务器提供服务的端口
						connectionFactory.setVirtualHost("/test");//虚拟主机
						connectionFactory.setUsername("zhangsan");//登录用户名
						connectionFactory.setPassword("123456");//登录密码					
					(b)第二步:通过连接工厂创建连接
						Connection connection = connectionFactory.newConnection();
					(c)第三步:通过连接创建消息通道
						Channel channel = connection.createChannel();
					(d)第四步:声明一个主题类型的交换机
						//参数列表
						//交换机名称，交换机类型，是否持久化交换机，是否在没有队列绑定时自动删除交换机，
						//是否是内置交换机(内置交换机，客户端无法向该交换机发送消息，只能通过交换机路由到该交换机)，其他结构化参数						
						channel.exchangeDeclare("topicExchange","topic",true,false,false,null);
					(e)第五步:声明一个队列
						//参数列表
						//队列名称，是否持久化队列，是否独占的(如果是独占的，会对队列加锁，同时只能有一个客户端可以访问该队列，可避免重复消费)，
						//是否自动删除队列(如果是自动删除，当最后一个消费者释放连接后会删除该队列)，其他结构化参数
						channel.queueDeclare("topicQueue",true,true,false,null);
					(f)第六步:建立交换机与消息队列的绑定关系
						String bindStr = "topic.#";//绑定topic前缀的所有路由键，通过路由键传递消息
						channel.queueBind("topicQueue","topicExchange",bindStr);
					(g)第七步:声明消费者
						QueueingConsumer queueingConsumer = new QueueingConsumer(channel);
					(h)第八步:消费消息
						channel.basicConsume("topicQueue",true,queueingConsumer);
						QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();
			(4)扇形交换机(FanoutExchange)
				[a]简述
					扇形交换机不需要绑定路由键，所有订阅了扇形交换机的队列都可以收到消息，由于扇形交换机没有一系列的队列匹配规则，所以扇形交换机的效率最高，
					但是在一些场景下不能使用，例如:下订单减库存的业务场景，所有的消息消费者都能够订阅到此消息，会造成业务的重复处理
				[a]消息提供者
					(a)第一步:创建连接工厂，并设置工厂属性
						ConnectionFactory connectionFactory = new ConnectionFactory();
						connectionFactory.setHost("111.231.111.161");//服务器ip
						connectionFactory.setPort(5672);//服务器提供服务的端口
						connectionFactory.setVirtualHost("/test");//虚拟主机
						connectionFactory.setUsername("zhangsan");//登录用户名
						connectionFactory.setPassword("123456");//登录密码					
					(b)第二步:通过连接工厂创建连接
						Connection connection = connectionFactory.newConnection();
					(c)第三步:通过连接创建消息通道
						Channel channel = connection.createChannel();
					(d)第四步:发送消息
						String fanoutExchangeName = "fanoutExchange";
						String routingKey = "fanoutRoutingKey";
						//参数列表
						//交换机名称，路由键，其他结构化参数，需要发布的消息
						channel.basicPublish(fanoutExchangeName,routingKey,null,"测试扇形交换机。。。。。。".getBytes());
				[b]消息消费者
					(a)第一步:创建连接工厂，并设置工厂属性
						ConnectionFactory connectionFactory = new ConnectionFactory();
						connectionFactory.setHost("111.231.111.161");//服务器ip
						connectionFactory.setPort(5672);//服务器提供服务的端口
						connectionFactory.setVirtualHost("/test");//虚拟主机
						connectionFactory.setUsername("zhangsan");//登录用户名
						connectionFactory.setPassword("123456");//登录密码					
					(b)第二步:通过连接工厂创建连接
						Connection connection = connectionFactory.newConnection();
					(c)第三步:通过连接创建消息通道
						Channel channel = connection.createChannel();
					(d)第四步:创建扇形交换机
						//参数列表
						//交换机名称，交换机类型，是否持久化交换机，是否自动删除，是否独占，其他结构化参数
						channel.exchangeDeclare("fanoutExchange","fanout",true,false,false,null);
			(5)头交换机(HandersExchange)
				[a]消息提供者
				[b]消息消费者
			(6)基础属性(消息头信息)
				Map<String,Object> headsMap = new HashMap<>();
				headsMap.put("company","companyName");
				headsMap.put("name","employeeName");
			
				AMQP.BasicProperties basicProperties = new AMQP.BasicProperties().builder()
					.deliveryMode(2)//2标识持久化消息  1标识 服务重启后 消息不会被持久化
					.expiration("10000")//消息过期10s，当消息10s时还没被消费时，该消息会被交换机删除掉
					.contentEncoding("utf-8")
					.correlationId(UUID.randomUUID().toString())//用作可靠性投递
					.headers(headsMap)
					.build();
		[4]SpringBoot集成
			(1)引入依赖
				<dependency>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-amqp</artifactId>
					<version>2.1.6.RELEASE</version>
				</dependency>
			(2)配置信息(application.properties)
				#RabbitMq
				spring.rabbitmq.host=111.231.111.161
				spring.rabbitmq.port=5672
				spring.rabbitmq.username=zhangsan
				spring.rabbitmq.password=123456
				spring.rabbitmq.virtual-host=/


				#开启消息确认模式
				spring.rabbitmq.publisher-confirms=true
				#开启消息可达监听
				spring.rabbitmq.publisher-returns=true
				#开启不可达消息不会被broker给删除
				spring.rabbitmq.template.mandatory=true
				#设置连接超时
				spring.rabbitmq.connection-timeout=10000		
			(3)@Bean注入
				[a]创建队列
					@Bean
					public Queue queue() {
						//队列名称，是否持久化
						return new Queue("queue-name",true);
					}
				[b]创建交换机
					@Bean
					public DirectExchange exchange() {
						//交换机名称，是否持久化，是否自动删除
						return new DirectExchange("exchange-name",true,false);
					}
				[c]将交换机与队列通过路由键绑定
					@Bean
					public Binding binding(Queue queue, DirectExchange exchange) {
						//通过路由键将队列绑定到交换机上
						return BindingBuilder.bind(queue).to(exchange).with("routingKey");
					}			
			(4)注解
				[a]消息提供者
					@Service
					public class MessageServiceImpl extends BaseServiceImpl<Message> implements MessageService{

						@Autowired
						private RabbitTemplate rabbitTemplate;

						@Override
						public void sendMessage(Message message){
							//通过rabbitTemplate向交换机发送消息，并携带路由键
							rabbitTemplate.convertAndSend("exchange-name","routingKey",message);
						}
					}
				[b]消息消费者
					//监听多个队列
					@Service
					@RabbitListener(queues = {"queue-name"})
					public class MessageServiceImpl extends BaseServiceImpl<Message> implements MessageService {
						
						//接收消息的方法
						@RabbitHandler
						@Override
						public void acceptMessage(Message message) {
							System.out.println(message);
						}
					}
		[5]支持客户端语言
			Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX
		[6]特点
			(1)优点
				[a]支持单机与集群模式，集群模式下支持主从模式，可用性高
				[b]由于erlang的语言特性，使用RAM模式时性能很好
				[c]数据可靠性比较好，支持同步/异步的可靠性投递
				[d]支持队列数据的持久化
				[e]镜像模式下支持主从同步
				[f]比较成熟的开源框架，社区活跃性和API与文档完备性较高
			(2)缺点
				[a]新加入的从服务器不会同步主服务器数据，可能会造成数据丢失
				[b]消息堆积程度与性能呈反比，堆积数据量过大，会有明显的性能下降
				[c]erlang语言难度较大，集群不支持动态扩展
				[d]不支持事务消息，消息吞吐能力有限
		[7]可靠性投递
			(1)生产者到broker
			
			(2)broker到消费者

			(3)通过定时任务实现
			
			(4)
		[8]消息持久化
		
		[9]RabbitMQ集群搭建
		
		[10]RabbitMQ高级特性
		
	7、ZeroMQ

三十四、SpringBoot
	
三十五、SpringCloud

三十六、Eureka

三十七、Ribbon

三十八、Feign

三十九、Hystrix

四十、Zuul

四十一、Sleuth、Cat

四十二、Docker

四十三、Kubernetes

四十四、人工智能
	1、Python
	2、神经网络
	3、脑类计算
	4、深度学习
	
四十五、区块链
	1、共识机制
	2、工作量证明原理
	3、挖矿算法
	4、密码学
	
四十六、大数据
	1、Hadoop
	2、Spark
	3、数据挖掘
	4、MapReduce
四十七、物联网技术
	1、RFID射频识别技术
	2、传感网
	3、M2M系统框架
	4、云计算